// SPDX-License-Identifier: GPL-3.0-or-later
// Copyright (c) 2024 Team Dissolve and contributors

#pragma once

#include "data/ff/ff.h"
#include "math/data1D.h"
#include "math/function1D.h"
#include "math/interpolator.h"
#include <memory>

// Forward Declarations
class AtomType;

// PairPotential Definition
class PairPotential : Serialisable<>
{
    public:
    PairPotential(std::string_view nameI = {}, std::string_view nameJ = {});
    PairPotential(std::string_view nameI, std::string_view nameJ, const InteractionPotential<Functions1D> &potential);
    // Coulomb Truncation Scheme enum
    enum CoulombTruncationScheme
    {
        NoCoulombTruncation,     /* No truncation scheme */
        ShiftedCoulombTruncation /* Shifted and truncated */
    };
    // Return enum options for CoulombTruncationScheme
    static EnumOptions<PairPotential::CoulombTruncationScheme> coulombTruncationSchemes();
    // Short-Range Truncation Scheme enum
    enum ShortRangeTruncationScheme
    {
        NoShortRangeTruncation,     /* No truncation scheme */
        ShiftedShortRangeTruncation /* Shifted and truncated */
    };
    // Return enum options for ShortRangeTruncationScheme
    static EnumOptions<PairPotential::ShortRangeTruncationScheme> shortRangeTruncationSchemes();
    // Typedefs
    using Definition = std::tuple<std::shared_ptr<AtomType>, std::shared_ptr<AtomType>, std::unique_ptr<PairPotential>>;

    /*
     * Seed Interaction Type
     */
    private:
    // Truncation scheme to apply to short-range part of potential
    static ShortRangeTruncationScheme shortRangeTruncationScheme_;
    // Short-range energy at cutoff distance (used by truncation scheme)
    double shortRangeEnergyAtCutoff_{0.0};
    // Short-range force at cutoff distance (used by truncation scheme)
    double shortRangeForceAtCutoff_{0.0};
    // Whether Coulomb contributions should be included in the generated potential
    static bool includeCoulombPotential_;
    // Truncation scheme to apply to Coulomb part of potential
    static CoulombTruncationScheme coulombTruncationScheme_;

    public:
    // Set short-ranged truncation scheme
    static void setShortRangeTruncationScheme(ShortRangeTruncationScheme scheme);
    // Return short-ranged truncation scheme
    static ShortRangeTruncationScheme shortRangeTruncationScheme();
    // Set whether Coulomb contributions should be included in the generated potential
    static void setIncludeCoulombPotential(bool b);
    // Return whether Coulomb contributions should be included in the generated potential
    static bool includeCoulombPotential();
    // Set Coulomb truncation scheme
    static void setCoulombTruncationScheme(CoulombTruncationScheme scheme);
    // Return Coulomb truncation scheme
    static CoulombTruncationScheme coulombTruncationScheme();

    /*
     * Source Parameters
     */
    private:
    // Names reflecting target atom types for potential
    std::string nameI_, nameJ_;
    // Interaction potential and function
    InteractionPotential<Functions1D> interactionPotential_;
    Function1DWrapper potentialFunction_;
    // Charge product (if including Coulomb terms)
    double localChargeProduct_{0.0};

    private:
    // Set Data1D names from source AtomTypes
    void setData1DNames();

    public:
    // Set names reflecting target atom types for potential
    void setNames(std::string_view nameI, std::string_view nameJ);
    // Return name for first target atom type
    std::string_view nameI() const;
    // Return name for second target atom type
    std::string_view nameJ() const;
    // Set interaction potential
    bool setInteractionPotential(Functions1D::Form form, std::string_view parameters);
    bool setInteractionPotential(const InteractionPotential<Functions1D> &potential);
    // Set form of interaction potential
    void setInteractionPotentialForm(Functions1D::Form form);
    // Return interaction potential
    const InteractionPotential<Functions1D> &interactionPotential() const;
    // Return local charge product (if including Coulomb terms)
    double localChargeProduct() const;

    /*
     * Tabulated Potential
     */
    private:
    // Maximum distance of potential
    double range_{0.0};
    // Distance between points in tabulated potentials
    double delta_{-1.0}, rDelta_{0.0};
    // Tabulated original potential, calculated from AtomType parameters
    Data1D referenceShortRangePotential_, coulombPotential_;
    // Additional short-range potential, generated by some means
    Data1D additionalShortRangePotential_;
    // Total short-range potential: reference plus additional
    Data1D totalShortRangePotential_;
    // Total potential: reference and additional short-range plus Coulomb
    Data1D totalPotential_;
    // Interpolators for potentials
    Interpolator totalShortRangePotentialInterpolation_, coulombPotentialInterpolation_, totalPotentialInterpolation_;
    // Tabulated derivative of full potential
    Data1D derivative_;
    // Interpolators for derivatives
    Interpolator derivativeInterpolation_;

    private:
    // Return analytic short range potential energy
    double analyticShortRangeEnergy(
        double r, PairPotential::ShortRangeTruncationScheme truncation = PairPotential::shortRangeTruncationScheme()) const;
    // Return analytic short range force
    double analyticShortRangeForce(
        double r, PairPotential::ShortRangeTruncationScheme truncation = PairPotential::shortRangeTruncationScheme()) const;
    // Update totals
    void updateTotals();

    public:
    // Generate energy and force tables
    void tabulate(double maxR, double delta, double chargeProduct = 0.0);
    // Add supplied function to the reference short-range potential
    void addToReferenceShortRangePotential(const Function1DWrapper &potential, bool overwriteExisting = false);
    // Return range of potential
    double range() const;
    // Return spacing between points
    double delta() const;
    // Return potential at specified r
    double energy(double r);
    double energy(double r, double elecScale, double srScale);
    // Return analytic potential at specified r, including Coulomb term from local charge product
    double analyticEnergy(double r, double elecScale, double srScale) const;
    // Return analytic potential at specified r, including Coulomb term from supplied charge product
    double analyticEnergy(double qiqj, double r, double elecScale, double srScale,
                          PairPotential::CoulombTruncationScheme truncation = PairPotential::coulombTruncationScheme()) const;
    // Return analytic coulomb potential energy of specified charge product
    double
    analyticCoulombEnergy(double qiqj, double r,
                          PairPotential::CoulombTruncationScheme truncation = PairPotential::coulombTruncationScheme()) const;
    // Return derivative of potential at specified r
    double force(double r);
    // Return analytic force at specified r, including Coulomb term from local charge product
    double analyticForce(double r, double elecScale, double srScale) const;
    // Return analytic force at specified r, including Coulomb term from supplied charge product
    double analyticForce(double qiqj, double r, double elecScale, double srScale,
                         PairPotential::CoulombTruncationScheme truncation = PairPotential::coulombTruncationScheme()) const;
    // Return analytic coulomb force of specified charge product
    double
    analyticCoulombForce(double qiqj, double r,
                         PairPotential::CoulombTruncationScheme truncation = PairPotential::coulombTruncationScheme()) const;
    // Return full tabulated potential
    const Data1D &totalPotential() const;
    // Return full tabulated derivative
    const Data1D &derivative() const;
    // Return short range potential
    const Data1D &shortRangePotential() const;
    // Return Coulomb potential
    const Data1D &coulombPotential() const;
    // Return additional potential
    const Data1D &additionalPotential() const;
    // Zero additional potential
    void resetAdditionalPotential();
    // Set additional potential
    void setAdditionalPotential(Data1D &newUAdditional);

    /*
     * I/O
     */
    public:
    // Express as a serialisable value
    SerialisedValue serialise() const override;
    // Read values from a serialisable value
    void deserialise(const SerialisedValue &node);
};
