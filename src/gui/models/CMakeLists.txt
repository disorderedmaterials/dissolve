set(models_MOC_HDRS
    addForcefieldDialogModel.h
    addSpeciesInfoModel.h
    atomTypeModel.h
    braggReflectionFilterProxy.h
    braggReflectionModel.h
    cifAssemblyModel.h
    configurationModel.h
    dataManagerSimulationModel.h
    enumOptionsModel.h
    forcefieldModel.h
    isotopologueSetModel.h
    masterAngleModel.h
    masterBondModel.h
    masterImproperModel.h
    masterTermModel.h
    masterTermTreeModel.h
    masterTorsionModel.h
    moduleLayerModel.h
    moduleLayersModel.h
    moduleModel.h
    nodePaletteFilterProxy.h
    modulePaletteModel.h
    nodePaletteModel.h
    pairPotentialModel.h
    procedureModel.h
    procedureNodeModel.h
    rangeVectorModel.h
    renderableGroupManagerModel.h
    sitesFilterProxy.h
    sitesModel.h
    speciesFilterProxy.h
    speciesModel.h
    speciesSiteFilterProxy.h
    speciesSiteModel.h
    speciesAngleModel.h
    speciesAtomModel.h
    speciesBondModel.h
    speciesImproperModel.h
    speciesIsoModel.h
    speciesTorsionModel.h
    weightedModuleModel.h
    xmlAngleModel.h
    xmlAtomModel.h
    xmlBondModel.h
    xmlImproperModel.h
    xmlTreeModel.h
    xmlTorsionModel.h
)

qt6_wrap_cpp(models_MOC_SRCS ${models_MOC_HDRS})

set(models_SRCS
    addForcefieldDialogModel.cpp
    addSpeciesInfoModel.cpp
    atomTypeFilterProxy.cpp
    atomTypeModel.cpp
    braggReflectionFilterProxy.cpp
    braggReflectionModel.cpp
    cifAssemblyModel.cpp
    configurationModel.cpp
    dataManagerSimulationModel.cpp
    enumOptionsModel.cpp
    expressionVariableVectorModel.cpp
    externalPotentialModel.cpp
    ffSortFilterModel.cpp
    forcefieldModel.cpp
    globalPotentialFilterProxy.cpp
    isotopologueSetModel.cpp
    masterAngleModel.cpp
    masterBondModel.cpp
    masterImproperModel.cpp
    masterTermModel.cpp
    masterTermTreeModel.cpp
    masterTorsionModel.cpp
    moduleLayerModel.cpp
    moduleLayersModel.cpp
    moduleModel.cpp
    nodePaletteFilterProxy.cpp
    modulePaletteModel.cpp
    nodePaletteModel.cpp
    pairPotentialModel.cpp
    procedureModel.cpp
    procedureModelMimeData.cpp
    procedureNodeModel.cpp
    rangeVectorModel.cpp
    renderableGroupManagerModel.cpp
    sitesFilterProxy.cpp
    sitesModel.cpp
    speciesAngleModel.cpp
    speciesAtomModel.cpp
    speciesBondModel.cpp
    speciesFilterProxy.cpp
    speciesImproperModel.cpp
    speciesIsoModel.cpp
    speciesModel.cpp
    speciesSiteFilterProxy.cpp
    speciesSiteModel.cpp
    speciesTorsionModel.cpp
    weightedModuleModel.cpp
    xmlAngleModel.cpp
    xmlAtomModel.cpp
    xmlBondModel.cpp
    xmlImproperModel.cpp
    xmlTreeModel.cpp
    xmlTorsionModel.cpp
)

qt6_wrap_cpp(
  models_SRCS
  atomTypeFilterProxy.h
  atomTypeModel.h
  braggReflectionModel.h
  dataManagerSimulationModel.h
  enumOptionsModel.h
  expressionVariableVectorModel.h
  forcefieldModel.h
  isotopologueSetModel.h
  pairPotentialModel.h
  procedureModelMimeData.h
  rangeVectorModel.h
  speciesAngleModel.h
  speciesAtomModel.h
  speciesBondModel.h
  speciesImproperModel.h
  speciesIsoModel.h
  speciesModel.h
  speciesSiteModel.h
  speciesTorsionModel.h
  weightedModuleModel.h
  xmlAngleModel.h
  xmlAtomModel.h
  xmlBondModel.h
  xmlImproperModel.h
  xmlTreeModel.h
  xmlTorsionModel.h
)

add_library(models ${models_SRCS} ${models_MOC_SRCS})

target_include_directories(
  models PRIVATE ${PROJECT_SOURCE_DIR}/src ${PROJECT_BINARY_DIR}/src ${CONAN_INCLUDE_DIRS_PUGIXML} ${Qt6Widgets_INCLUDE_DIRS}
                 ${FREETYPE_INCLUDE_DIRS}
)

# Because Qt has its own way of checking for C++17
if(MSVC)
  target_compile_options(models PUBLIC /Zc:__cplusplus)
endif(MSVC)

if(CONAN)
  target_link_libraries(models PUBLIC CONAN_PKG::pugixml ${THREADING_LINK_LIBS})
else(CONAN)
  target_link_libraries(models PUBLIC pugixml::pugixml ${THREADING_LINK_LIBS})
endif(CONAN)
