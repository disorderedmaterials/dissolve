set(models_MOC_HDRS
    addSpeciesInfoModel.h
    atomTypeModel.h
    braggReflectionFilterProxy.h
    braggReflectionModel.h
    cifAssemblyModel.h
    configurationModel.h
    dataManagerSimulationModel.h
    enumOptionsModel.h
    isotopologueSetModel.h
    masterAngleModel.h
    masterBondModel.h
    masterImproperModel.h
    masterTermModel.h
    masterTermTreeModel.h
    masterTorsionModel.h
    moduleLayerModel.h
    moduleLayersModel.h
    moduleModel.h
    nodePaletteFilterProxy.h
    modulePaletteModel.h
    nodePaletteModel.h
    pairPotentialModel.h
    procedureModel.h
    procedureModelMimeData.h
    procedureNodeModel.h
    renderableGroupManagerModel.h
    sitesFilterProxy.h
    sitesModel.h
    speciesFilterProxy.h
    speciesModel.h
    speciesSiteFilterProxy.h
    speciesSiteModel.h
    xmlAngleModel.h
    xmlAtomModel.h
    xmlBondModel.h
    xmlImproperModel.h
    xmlTreeModel.h
    xmlTorsionModel.h
    speciesAngleModel.h
    speciesAtomModel.h
    speciesBondModel.h
    speciesImproperModel.h
    speciesIsoModel.h
    speciesTorsionModel.h
    weightedModuleModel.h
    rangeModel.h
)

qt6_wrap_cpp(models_MOC_SRCS ${models_MOC_HDRS})

set(models_SRCS
    addSpeciesInfoModel.cpp
    atomTypeFilterProxy.cpp
    atomTypeModel.cpp
    braggReflectionFilterProxy.cpp
    braggReflectionModel.cpp
    cifAssemblyModel.cpp
    configurationModel.cpp
    dataManagerSimulationModel.cpp
    enumOptionsModel.cpp
    expressionVariableVectorModel.cpp
    isotopologueSetModel.cpp
    masterAngleModel.cpp
    masterBondModel.cpp
    masterImproperModel.cpp
    masterTermModel.cpp
    masterTermTreeModel.cpp
    masterTorsionModel.cpp
    moduleLayerModel.cpp
    moduleLayersModel.cpp
    moduleModel.cpp
    nodePaletteFilterProxy.cpp
    modulePaletteModel.cpp
    nodePaletteModel.cpp
    pairPotentialModel.cpp
    procedureModel.cpp
    procedureModelMimeData.cpp
    procedureNodeModel.cpp
    renderableGroupManagerModel.cpp
    sitesFilterProxy.cpp
    sitesModel.cpp
    speciesAngleModel.cpp
    speciesAtomModel.cpp
    speciesBondModel.cpp
    speciesFilterProxy.cpp
    speciesImproperModel.cpp
    speciesIsoModel.cpp
    speciesModel.cpp
    speciesSiteFilterProxy.cpp
    speciesSiteModel.cpp
    speciesTorsionModel.cpp
    weightedModuleModel.cpp
    rangeModel.cpp
    xmlAngleModel.cpp
    xmlAtomModel.cpp
    xmlBondModel.cpp
    xmlImproperModel.cpp
    xmlTreeModel.cpp
    xmlTorsionModel.cpp
)

qt_wrap_cpp(
  models_SRCS
  atomTypeFilterProxy.h
  atomTypeModel.h
  braggReflectionModel.h
  dataManagerSimulationModel.h
  enumOptionsModel.h
  expressionVariableVectorModel.h
  isotopologueSetModel.h
  pairPotentialModel.h
  speciesModel.h
  speciesSiteModel.h
  xmlAngleModel.h
  xmlAtomModel.h
  xmlBondModel.h
  xmlImproperModel.h
  xmlTreeModel.h
  xmlTorsionModel.h
  speciesAngleModel.h
  speciesAtomModel.h
  speciesBondModel.h
  speciesImproperModel.h
  speciesIsoModel.h
  speciesTorsionModel.h
  weightedModuleModel.h
  rangeModel.h
)

add_library(models ${models_SRCS} ${models_MOC_SRCS})

target_include_directories(
  models PRIVATE ${PROJECT_SOURCE_DIR}/src ${PROJECT_BINARY_DIR}/src ${CONAN_INCLUDE_DIRS_PUGIXML} ${Qt6Widgets_INCLUDE_DIRS}
                 ${FREETYPE_INCLUDE_DIRS}
)

# Because Qt has its own way of checking for C++17
if(MSVC)
  target_compile_options(models PUBLIC /Zc:__cplusplus)
endif(MSVC)

if(CONAN)
  target_link_libraries(models PUBLIC CONAN_PKG::pugixml ${THREADING_LINK_LIBS})
else(CONAN)
  target_link_libraries(models PUBLIC pugixml::pugixml ${THREADING_LINK_LIBS})
endif(CONAN)
